# Generated from C:/Users/MSI/Pictures/CompilerProjcet/pythonProject1/backendgrammer.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,71,445,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,1,0,1,0,1,0,5,
        0,94,8,0,10,0,12,0,97,9,0,1,1,1,1,1,1,1,1,4,1,103,8,1,11,1,12,1,
        104,1,1,1,1,1,2,1,2,1,3,1,3,1,3,1,3,1,3,5,3,116,8,3,10,3,12,3,119,
        9,3,1,3,1,3,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,132,8,5,1,6,
        1,6,1,6,1,6,1,6,3,6,139,8,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,
        1,8,1,8,1,8,1,8,4,8,154,8,8,11,8,12,8,155,3,8,158,8,8,1,8,1,8,1,
        9,1,9,1,9,1,9,1,9,3,9,167,8,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,
        4,10,176,8,10,11,10,12,10,177,3,10,180,8,10,1,10,1,10,1,11,1,11,
        1,11,1,11,1,11,1,11,1,11,4,11,191,8,11,11,11,12,11,192,3,11,195,
        8,11,1,11,1,11,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,13,1,14,1,14,
        1,14,1,14,1,15,1,15,1,16,1,16,1,17,1,17,1,18,1,18,1,18,1,18,1,18,
        1,18,1,19,1,19,1,20,1,20,1,20,1,20,5,20,229,8,20,10,20,12,20,232,
        9,20,3,20,234,8,20,1,21,1,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,
        1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,1,26,1,26,1,26,1,26,
        1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,266,8,26,1,27,1,27,
        1,27,1,27,1,28,1,28,1,28,1,28,1,28,1,28,3,28,278,8,28,1,29,5,29,
        281,8,29,10,29,12,29,284,9,29,1,29,1,29,1,29,1,29,1,30,1,30,1,30,
        1,30,1,30,1,31,1,31,3,31,297,8,31,1,32,1,32,1,32,1,32,1,32,1,32,
        5,32,305,8,32,10,32,12,32,308,9,32,1,33,1,33,1,33,1,33,1,33,1,33,
        5,33,316,8,33,10,33,12,33,319,9,33,1,34,1,34,1,34,1,34,1,34,1,34,
        3,34,327,8,34,1,35,1,35,1,35,1,35,1,36,1,36,1,37,1,37,1,37,1,37,
        1,37,5,37,340,8,37,10,37,12,37,343,9,37,3,37,345,8,37,1,37,1,37,
        1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,5,37,357,8,37,10,37,12,37,
        360,9,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,5,37,
        372,8,37,10,37,12,37,375,9,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,
        1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,
        1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,37,406,8,37,1,37,
        1,37,3,37,410,8,37,1,37,1,37,3,37,414,8,37,1,37,1,37,1,37,1,37,1,
        37,3,37,421,8,37,1,38,1,38,1,38,1,38,1,39,1,39,1,40,1,40,1,40,3,
        40,432,8,40,1,41,3,41,435,8,41,1,41,1,41,1,42,1,42,1,43,1,43,1,44,
        1,44,1,44,0,2,64,66,45,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,
        32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,
        76,78,80,82,84,86,88,0,5,1,0,46,47,1,0,50,53,1,0,2,3,1,0,4,5,1,0,
        30,39,454,0,95,1,0,0,0,2,98,1,0,0,0,4,108,1,0,0,0,6,110,1,0,0,0,
        8,122,1,0,0,0,10,131,1,0,0,0,12,138,1,0,0,0,14,140,1,0,0,0,16,147,
        1,0,0,0,18,166,1,0,0,0,20,168,1,0,0,0,22,183,1,0,0,0,24,198,1,0,
        0,0,26,202,1,0,0,0,28,206,1,0,0,0,30,210,1,0,0,0,32,212,1,0,0,0,
        34,214,1,0,0,0,36,216,1,0,0,0,38,222,1,0,0,0,40,233,1,0,0,0,42,235,
        1,0,0,0,44,237,1,0,0,0,46,246,1,0,0,0,48,248,1,0,0,0,50,250,1,0,
        0,0,52,265,1,0,0,0,54,267,1,0,0,0,56,277,1,0,0,0,58,282,1,0,0,0,
        60,289,1,0,0,0,62,296,1,0,0,0,64,298,1,0,0,0,66,309,1,0,0,0,68,326,
        1,0,0,0,70,328,1,0,0,0,72,332,1,0,0,0,74,420,1,0,0,0,76,422,1,0,
        0,0,78,426,1,0,0,0,80,431,1,0,0,0,82,434,1,0,0,0,84,438,1,0,0,0,
        86,440,1,0,0,0,88,442,1,0,0,0,90,94,3,2,1,0,91,94,3,36,18,0,92,94,
        3,44,22,0,93,90,1,0,0,0,93,91,1,0,0,0,93,92,1,0,0,0,94,97,1,0,0,
        0,95,93,1,0,0,0,95,96,1,0,0,0,96,1,1,0,0,0,97,95,1,0,0,0,98,99,5,
        6,0,0,99,100,3,4,2,0,100,102,5,15,0,0,101,103,3,6,3,0,102,101,1,
        0,0,0,103,104,1,0,0,0,104,102,1,0,0,0,104,105,1,0,0,0,105,106,1,
        0,0,0,106,107,5,16,0,0,107,3,1,0,0,0,108,109,3,88,44,0,109,5,1,0,
        0,0,110,111,3,8,4,0,111,112,5,17,0,0,112,117,3,10,5,0,113,114,5,
        13,0,0,114,116,3,12,6,0,115,113,1,0,0,0,116,119,1,0,0,0,117,115,
        1,0,0,0,117,118,1,0,0,0,118,120,1,0,0,0,119,117,1,0,0,0,120,121,
        5,18,0,0,121,7,1,0,0,0,122,123,3,88,44,0,123,9,1,0,0,0,124,132,5,
        7,0,0,125,132,5,8,0,0,126,132,5,9,0,0,127,132,5,10,0,0,128,132,5,
        11,0,0,129,132,5,12,0,0,130,132,3,88,44,0,131,124,1,0,0,0,131,125,
        1,0,0,0,131,126,1,0,0,0,131,127,1,0,0,0,131,128,1,0,0,0,131,129,
        1,0,0,0,131,130,1,0,0,0,132,11,1,0,0,0,133,139,3,34,17,0,134,139,
        3,32,16,0,135,139,3,30,15,0,136,139,3,16,8,0,137,139,3,14,7,0,138,
        133,1,0,0,0,138,134,1,0,0,0,138,135,1,0,0,0,138,136,1,0,0,0,138,
        137,1,0,0,0,139,13,1,0,0,0,140,141,5,14,0,0,141,142,5,19,0,0,142,
        143,3,4,2,0,143,144,5,21,0,0,144,145,3,8,4,0,145,146,5,20,0,0,146,
        15,1,0,0,0,147,148,5,22,0,0,148,157,5,23,0,0,149,158,3,18,9,0,150,
        153,3,18,9,0,151,152,5,25,0,0,152,154,3,18,9,0,153,151,1,0,0,0,154,
        155,1,0,0,0,155,153,1,0,0,0,155,156,1,0,0,0,156,158,1,0,0,0,157,
        149,1,0,0,0,157,150,1,0,0,0,157,158,1,0,0,0,158,159,1,0,0,0,159,
        160,5,24,0,0,160,17,1,0,0,0,161,167,3,28,14,0,162,167,3,26,13,0,
        163,167,3,24,12,0,164,167,3,22,11,0,165,167,3,20,10,0,166,161,1,
        0,0,0,166,162,1,0,0,0,166,163,1,0,0,0,166,164,1,0,0,0,166,165,1,
        0,0,0,167,19,1,0,0,0,168,169,5,40,0,0,169,170,5,26,0,0,170,179,5,
        15,0,0,171,180,3,80,40,0,172,175,3,80,40,0,173,174,5,25,0,0,174,
        176,3,80,40,0,175,173,1,0,0,0,176,177,1,0,0,0,177,175,1,0,0,0,177,
        178,1,0,0,0,178,180,1,0,0,0,179,171,1,0,0,0,179,172,1,0,0,0,179,
        180,1,0,0,0,180,181,1,0,0,0,181,182,5,16,0,0,182,21,1,0,0,0,183,
        184,5,41,0,0,184,185,5,26,0,0,185,194,5,15,0,0,186,195,3,80,40,0,
        187,190,3,80,40,0,188,189,5,25,0,0,189,191,3,80,40,0,190,188,1,0,
        0,0,191,192,1,0,0,0,192,190,1,0,0,0,192,193,1,0,0,0,193,195,1,0,
        0,0,194,186,1,0,0,0,194,187,1,0,0,0,194,195,1,0,0,0,195,196,1,0,
        0,0,196,197,5,16,0,0,197,23,1,0,0,0,198,199,5,42,0,0,199,200,5,26,
        0,0,200,201,3,84,42,0,201,25,1,0,0,0,202,203,5,43,0,0,203,204,5,
        26,0,0,204,205,3,80,40,0,205,27,1,0,0,0,206,207,5,44,0,0,207,208,
        5,26,0,0,208,209,3,80,40,0,209,29,1,0,0,0,210,211,5,45,0,0,211,31,
        1,0,0,0,212,213,7,0,0,0,213,33,1,0,0,0,214,215,5,48,0,0,215,35,1,
        0,0,0,216,217,5,49,0,0,217,218,3,38,19,0,218,219,5,15,0,0,219,220,
        3,40,20,0,220,221,5,16,0,0,221,37,1,0,0,0,222,223,3,88,44,0,223,
        39,1,0,0,0,224,234,3,42,21,0,225,230,3,42,21,0,226,227,5,25,0,0,
        227,229,3,42,21,0,228,226,1,0,0,0,229,232,1,0,0,0,230,228,1,0,0,
        0,230,231,1,0,0,0,231,234,1,0,0,0,232,230,1,0,0,0,233,224,1,0,0,
        0,233,225,1,0,0,0,234,41,1,0,0,0,235,236,3,80,40,0,236,43,1,0,0,
        0,237,238,5,1,0,0,238,239,3,46,23,0,239,240,5,17,0,0,240,241,3,48,
        24,0,241,242,3,50,25,0,242,243,5,15,0,0,243,244,3,52,26,0,244,245,
        5,16,0,0,245,45,1,0,0,0,246,247,3,88,44,0,247,47,1,0,0,0,248,249,
        7,1,0,0,249,49,1,0,0,0,250,251,3,84,42,0,251,51,1,0,0,0,252,253,
        3,54,27,0,253,254,5,18,0,0,254,255,3,70,35,0,255,256,5,18,0,0,256,
        266,1,0,0,0,257,258,3,70,35,0,258,259,5,18,0,0,259,260,3,54,27,0,
        260,261,5,18,0,0,261,266,1,0,0,0,262,263,3,54,27,0,263,264,5,18,
        0,0,264,266,1,0,0,0,265,252,1,0,0,0,265,257,1,0,0,0,265,262,1,0,
        0,0,266,53,1,0,0,0,267,268,5,54,0,0,268,269,5,17,0,0,269,270,3,56,
        28,0,270,55,1,0,0,0,271,278,3,4,2,0,272,273,5,56,0,0,273,274,5,15,
        0,0,274,275,3,58,29,0,275,276,5,16,0,0,276,278,1,0,0,0,277,271,1,
        0,0,0,277,272,1,0,0,0,278,57,1,0,0,0,279,281,3,60,30,0,280,279,1,
        0,0,0,281,284,1,0,0,0,282,280,1,0,0,0,282,283,1,0,0,0,283,285,1,
        0,0,0,284,282,1,0,0,0,285,286,5,57,0,0,286,287,3,62,31,0,287,288,
        5,18,0,0,288,59,1,0,0,0,289,290,3,88,44,0,290,291,5,26,0,0,291,292,
        3,62,31,0,292,293,5,18,0,0,293,61,1,0,0,0,294,297,3,64,32,0,295,
        297,3,74,37,0,296,294,1,0,0,0,296,295,1,0,0,0,297,63,1,0,0,0,298,
        299,6,32,-1,0,299,300,3,66,33,0,300,306,1,0,0,0,301,302,10,2,0,0,
        302,303,7,2,0,0,303,305,3,66,33,0,304,301,1,0,0,0,305,308,1,0,0,
        0,306,304,1,0,0,0,306,307,1,0,0,0,307,65,1,0,0,0,308,306,1,0,0,0,
        309,310,6,33,-1,0,310,311,3,68,34,0,311,317,1,0,0,0,312,313,10,2,
        0,0,313,314,7,3,0,0,314,316,3,68,34,0,315,312,1,0,0,0,316,319,1,
        0,0,0,317,315,1,0,0,0,317,318,1,0,0,0,318,67,1,0,0,0,319,317,1,0,
        0,0,320,327,3,88,44,0,321,327,3,80,40,0,322,323,5,19,0,0,323,324,
        3,64,32,0,324,325,5,20,0,0,325,327,1,0,0,0,326,320,1,0,0,0,326,321,
        1,0,0,0,326,322,1,0,0,0,327,69,1,0,0,0,328,329,5,55,0,0,329,330,
        5,17,0,0,330,331,3,72,36,0,331,71,1,0,0,0,332,333,3,84,42,0,333,
        73,1,0,0,0,334,335,5,58,0,0,335,344,5,27,0,0,336,341,3,76,38,0,337,
        338,5,25,0,0,338,340,3,76,38,0,339,337,1,0,0,0,340,343,1,0,0,0,341,
        339,1,0,0,0,341,342,1,0,0,0,342,345,1,0,0,0,343,341,1,0,0,0,344,
        336,1,0,0,0,344,345,1,0,0,0,345,346,1,0,0,0,346,347,5,28,0,0,347,
        348,5,19,0,0,348,349,3,62,31,0,349,350,5,20,0,0,350,421,1,0,0,0,
        351,352,5,59,0,0,352,353,5,27,0,0,353,358,3,88,44,0,354,355,5,25,
        0,0,355,357,3,88,44,0,356,354,1,0,0,0,357,360,1,0,0,0,358,356,1,
        0,0,0,358,359,1,0,0,0,359,361,1,0,0,0,360,358,1,0,0,0,361,362,5,
        28,0,0,362,363,5,19,0,0,363,364,3,62,31,0,364,365,5,20,0,0,365,421,
        1,0,0,0,366,367,5,60,0,0,367,368,5,27,0,0,368,373,3,88,44,0,369,
        370,5,25,0,0,370,372,3,88,44,0,371,369,1,0,0,0,372,375,1,0,0,0,373,
        371,1,0,0,0,373,374,1,0,0,0,374,376,1,0,0,0,375,373,1,0,0,0,376,
        377,5,28,0,0,377,378,5,19,0,0,378,379,3,62,31,0,379,380,5,25,0,0,
        380,381,3,62,31,0,381,382,5,20,0,0,382,421,1,0,0,0,383,384,5,64,
        0,0,384,385,5,19,0,0,385,386,3,62,31,0,386,387,5,20,0,0,387,421,
        1,0,0,0,388,389,5,61,0,0,389,390,5,19,0,0,390,391,3,62,31,0,391,
        392,5,25,0,0,392,393,3,62,31,0,393,394,5,20,0,0,394,421,1,0,0,0,
        395,396,5,63,0,0,396,397,5,19,0,0,397,398,3,62,31,0,398,399,5,25,
        0,0,399,400,3,86,43,0,400,401,5,20,0,0,401,421,1,0,0,0,402,403,5,
        62,0,0,403,405,5,27,0,0,404,406,3,64,32,0,405,404,1,0,0,0,405,406,
        1,0,0,0,406,407,1,0,0,0,407,409,5,25,0,0,408,410,3,64,32,0,409,408,
        1,0,0,0,409,410,1,0,0,0,410,411,1,0,0,0,411,413,5,25,0,0,412,414,
        3,64,32,0,413,412,1,0,0,0,413,414,1,0,0,0,414,415,1,0,0,0,415,416,
        5,28,0,0,416,417,5,19,0,0,417,418,3,62,31,0,418,419,5,20,0,0,419,
        421,1,0,0,0,420,334,1,0,0,0,420,351,1,0,0,0,420,366,1,0,0,0,420,
        383,1,0,0,0,420,388,1,0,0,0,420,395,1,0,0,0,420,402,1,0,0,0,421,
        75,1,0,0,0,422,423,3,88,44,0,423,424,3,78,39,0,424,425,3,64,32,0,
        425,77,1,0,0,0,426,427,7,4,0,0,427,79,1,0,0,0,428,432,3,82,41,0,
        429,432,3,84,42,0,430,432,3,86,43,0,431,428,1,0,0,0,431,429,1,0,
        0,0,431,430,1,0,0,0,432,81,1,0,0,0,433,435,7,2,0,0,434,433,1,0,0,
        0,434,435,1,0,0,0,435,436,1,0,0,0,436,437,5,65,0,0,437,83,1,0,0,
        0,438,439,5,66,0,0,439,85,1,0,0,0,440,441,5,67,0,0,441,87,1,0,0,
        0,442,443,5,68,0,0,443,89,1,0,0,0,32,93,95,104,117,131,138,155,157,
        166,177,179,192,194,230,233,265,277,282,296,306,317,326,341,344,
        358,373,405,409,413,420,431,434
    ]

class backendgrammerParser ( Parser ):

    grammarFileName = "backendgrammer.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'endpoint'", "'+'", "'-'", "'*'", "'/'", 
                     "'model'", "'String'", "'Int'", "'Date'", "'Double'", 
                     "'Time'", "'DateTime'", "'@'", "'foreign-key'", "'{'", 
                     "'}'", "':'", "';'", "'('", "')'", "'.'", "'valid'", 
                     "'['", "']'", "','", "'='", "'<'", "'>'", "'!'", "'eq'", 
                     "'lst'", "'grt'", "'lsteq'", "'grteq'", "'not-eq'", 
                     "'not-lst'", "'not-grt'", "'not-lsteq'", "'not-grteq'", 
                     "'exclude'", "'include'", "'wildpattern'", "'min'", 
                     "'max'", "'unique'", "'nullable'", "'non-nullable'", 
                     "'pk'", "'enum'", "'GET'", "'POST'", "'PUT'", "'DELETE'", 
                     "'response'", "'input'", "'relational'", "'->'", "'Select'", 
                     "'Project'", "<INVALID>", "<INVALID>", "'Limit'", "'Orderby'", 
                     "'Len'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "MODEL_KEY", "STRING_FILED_TYPE", 
                      "INT_FILED_TYPE", "DATE_FILED_TYPE", "DOUBLE_FILED_TYPE", 
                      "TIME_FILED_TYPE", "DATETIME_FILED_TYPE", "ATSIGN_KEY", 
                      "FK_KEY", "LEFT_CURLBR_KEY", "RIGHT_CURLBR_KEY", "COLON_KEY", 
                      "SEMICOLON_KEY", "LEFT_PAR_KEY", "RIGHT_PAR_KEY", 
                      "DOT_KEY", "VALID_KEY", "LEFT_BRACKET_KEY", "RIGHT_BRACKET_KEY", 
                      "COMMA_KEY", "EQUALSIGN_KEY", "LEFT_ANGLE_BRACKET_KEY", 
                      "RIGHT_ANGLE_BRACKET_KEY", "Exclamation_KEY", "EQUAL_KEY", 
                      "LESSTHAN_KEY", "GREATERTHAN_KEY", "LESSTHAN_OR_EQUAL_KEY", 
                      "GREATERTHAN_OR_EQUAL_KEY", "NOT_EQUAL_KEY", "NOT_LESSTHAN_KEY", 
                      "NOT_GREATERTHAN_KEY", "NOT_LESSTHAN_OR_EQUAL_KEY", 
                      "NOT_GREATERTHAN_OR_EQUAL_KEY", "EXCLUDE_KEY", "INCLUDE_KEY", 
                      "WILD_PATTERN_KEY", "MIN_KEY", "MAX_KEY", "UNIQUE_KEY", 
                      "NULLABLE_KEY", "NON_NULLABLE_KEY", "PK_KEY", "ENUM_KEY", 
                      "GET_KEY", "POST_KEY", "PUT_KEY", "DELETE_KEY", "RESPONSE_KEY", 
                      "INPUT_KEY", "RELATIONAL_KEY", "RETURN_ARROW_KEY", 
                      "SELECT_FUNCTION_KEY", "PROJECT_FUNCTION_KEY", "JOIN_FUNCTION_KEY", 
                      "SET_FUNCTION_KEY", "LIMIT_FUNCTION_KEY", "ORDERBY_FUNCTION_KEY", 
                      "LEN_FUNCTION_KEY", "DIGITS", "STRINGVALUE", "BOOLEANVALUE", 
                      "VARIABLEID", "SINGLELINE_COMMENT", "MULTILINE_COMMENT", 
                      "WS" ]

    RULE_compileinit = 0
    RULE_modelrole = 1
    RULE_modelname = 2
    RULE_modelenyty = 3
    RULE_fieldname = 4
    RULE_fieldtype = 5
    RULE_fieldannotaion = 6
    RULE_fkoption = 7
    RULE_validoption = 8
    RULE_validoptionparameter = 9
    RULE_exclude_validoptionparameter = 10
    RULE_include_validoptionparameter = 11
    RULE_wildpattern_validoptionparameter = 12
    RULE_min_validoptionparameter = 13
    RULE_max_validoptionparameter = 14
    RULE_uniqueoption = 15
    RULE_nulloption = 16
    RULE_pkoption = 17
    RULE_enumrole = 18
    RULE_enumname = 19
    RULE_enumblock = 20
    RULE_enumitem = 21
    RULE_endpointrule = 22
    RULE_operationId = 23
    RULE_htttpMethod = 24
    RULE_endpointurl = 25
    RULE_endpoinblock = 26
    RULE_responseblock = 27
    RULE_responseblock_inner = 28
    RULE_relationalcode = 29
    RULE_define_variable_relational = 30
    RULE_expr_relational = 31
    RULE_term_relational = 32
    RULE_idom_relational = 33
    RULE_factor_relational = 34
    RULE_inputblock = 35
    RULE_jsonstring = 36
    RULE_built_in_functions_relational = 37
    RULE_key_value_pair_select_relational = 38
    RULE_binary_logical_operation = 39
    RULE_genericvalue = 40
    RULE_intvalue = 41
    RULE_stringvalue = 42
    RULE_booleanvalue = 43
    RULE_variablename = 44

    ruleNames =  [ "compileinit", "modelrole", "modelname", "modelenyty", 
                   "fieldname", "fieldtype", "fieldannotaion", "fkoption", 
                   "validoption", "validoptionparameter", "exclude_validoptionparameter", 
                   "include_validoptionparameter", "wildpattern_validoptionparameter", 
                   "min_validoptionparameter", "max_validoptionparameter", 
                   "uniqueoption", "nulloption", "pkoption", "enumrole", 
                   "enumname", "enumblock", "enumitem", "endpointrule", 
                   "operationId", "htttpMethod", "endpointurl", "endpoinblock", 
                   "responseblock", "responseblock_inner", "relationalcode", 
                   "define_variable_relational", "expr_relational", "term_relational", 
                   "idom_relational", "factor_relational", "inputblock", 
                   "jsonstring", "built_in_functions_relational", "key_value_pair_select_relational", 
                   "binary_logical_operation", "genericvalue", "intvalue", 
                   "stringvalue", "booleanvalue", "variablename" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    MODEL_KEY=6
    STRING_FILED_TYPE=7
    INT_FILED_TYPE=8
    DATE_FILED_TYPE=9
    DOUBLE_FILED_TYPE=10
    TIME_FILED_TYPE=11
    DATETIME_FILED_TYPE=12
    ATSIGN_KEY=13
    FK_KEY=14
    LEFT_CURLBR_KEY=15
    RIGHT_CURLBR_KEY=16
    COLON_KEY=17
    SEMICOLON_KEY=18
    LEFT_PAR_KEY=19
    RIGHT_PAR_KEY=20
    DOT_KEY=21
    VALID_KEY=22
    LEFT_BRACKET_KEY=23
    RIGHT_BRACKET_KEY=24
    COMMA_KEY=25
    EQUALSIGN_KEY=26
    LEFT_ANGLE_BRACKET_KEY=27
    RIGHT_ANGLE_BRACKET_KEY=28
    Exclamation_KEY=29
    EQUAL_KEY=30
    LESSTHAN_KEY=31
    GREATERTHAN_KEY=32
    LESSTHAN_OR_EQUAL_KEY=33
    GREATERTHAN_OR_EQUAL_KEY=34
    NOT_EQUAL_KEY=35
    NOT_LESSTHAN_KEY=36
    NOT_GREATERTHAN_KEY=37
    NOT_LESSTHAN_OR_EQUAL_KEY=38
    NOT_GREATERTHAN_OR_EQUAL_KEY=39
    EXCLUDE_KEY=40
    INCLUDE_KEY=41
    WILD_PATTERN_KEY=42
    MIN_KEY=43
    MAX_KEY=44
    UNIQUE_KEY=45
    NULLABLE_KEY=46
    NON_NULLABLE_KEY=47
    PK_KEY=48
    ENUM_KEY=49
    GET_KEY=50
    POST_KEY=51
    PUT_KEY=52
    DELETE_KEY=53
    RESPONSE_KEY=54
    INPUT_KEY=55
    RELATIONAL_KEY=56
    RETURN_ARROW_KEY=57
    SELECT_FUNCTION_KEY=58
    PROJECT_FUNCTION_KEY=59
    JOIN_FUNCTION_KEY=60
    SET_FUNCTION_KEY=61
    LIMIT_FUNCTION_KEY=62
    ORDERBY_FUNCTION_KEY=63
    LEN_FUNCTION_KEY=64
    DIGITS=65
    STRINGVALUE=66
    BOOLEANVALUE=67
    VARIABLEID=68
    SINGLELINE_COMMENT=69
    MULTILINE_COMMENT=70
    WS=71

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class CompileinitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modelrole(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.ModelroleContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.ModelroleContext,i)


        def enumrole(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.EnumroleContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.EnumroleContext,i)


        def endpointrule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.EndpointruleContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.EndpointruleContext,i)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_compileinit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompileinit" ):
                listener.enterCompileinit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompileinit" ):
                listener.exitCompileinit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompileinit" ):
                return visitor.visitCompileinit(self)
            else:
                return visitor.visitChildren(self)




    def compileinit(self):

        localctx = backendgrammerParser.CompileinitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_compileinit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 562949953421378) != 0):
                self.state = 93
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [6]:
                    self.state = 90
                    self.modelrole()
                    pass
                elif token in [49]:
                    self.state = 91
                    self.enumrole()
                    pass
                elif token in [1]:
                    self.state = 92
                    self.endpointrule()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 97
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModelroleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODEL_KEY(self):
            return self.getToken(backendgrammerParser.MODEL_KEY, 0)

        def modelname(self):
            return self.getTypedRuleContext(backendgrammerParser.ModelnameContext,0)


        def LEFT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_CURLBR_KEY, 0)

        def RIGHT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_CURLBR_KEY, 0)

        def modelenyty(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.ModelenytyContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.ModelenytyContext,i)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_modelrole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModelrole" ):
                listener.enterModelrole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModelrole" ):
                listener.exitModelrole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModelrole" ):
                return visitor.visitModelrole(self)
            else:
                return visitor.visitChildren(self)




    def modelrole(self):

        localctx = backendgrammerParser.ModelroleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_modelrole)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(backendgrammerParser.MODEL_KEY)
            self.state = 99
            self.modelname()
            self.state = 100
            self.match(backendgrammerParser.LEFT_CURLBR_KEY)
            self.state = 102 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 101
                self.modelenyty()
                self.state = 104 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==68):
                    break

            self.state = 106
            self.match(backendgrammerParser.RIGHT_CURLBR_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModelnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_modelname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModelname" ):
                listener.enterModelname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModelname" ):
                listener.exitModelname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModelname" ):
                return visitor.visitModelname(self)
            else:
                return visitor.visitChildren(self)




    def modelname(self):

        localctx = backendgrammerParser.ModelnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_modelname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            self.variablename()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModelenytyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fieldname(self):
            return self.getTypedRuleContext(backendgrammerParser.FieldnameContext,0)


        def COLON_KEY(self):
            return self.getToken(backendgrammerParser.COLON_KEY, 0)

        def fieldtype(self):
            return self.getTypedRuleContext(backendgrammerParser.FieldtypeContext,0)


        def SEMICOLON_KEY(self):
            return self.getToken(backendgrammerParser.SEMICOLON_KEY, 0)

        def ATSIGN_KEY(self, i:int=None):
            if i is None:
                return self.getTokens(backendgrammerParser.ATSIGN_KEY)
            else:
                return self.getToken(backendgrammerParser.ATSIGN_KEY, i)

        def fieldannotaion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.FieldannotaionContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.FieldannotaionContext,i)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_modelenyty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModelenyty" ):
                listener.enterModelenyty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModelenyty" ):
                listener.exitModelenyty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModelenyty" ):
                return visitor.visitModelenyty(self)
            else:
                return visitor.visitChildren(self)




    def modelenyty(self):

        localctx = backendgrammerParser.ModelenytyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_modelenyty)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            self.fieldname()
            self.state = 111
            self.match(backendgrammerParser.COLON_KEY)
            self.state = 112
            self.fieldtype()
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==13:
                self.state = 113
                self.match(backendgrammerParser.ATSIGN_KEY)
                self.state = 114
                self.fieldannotaion()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 120
            self.match(backendgrammerParser.SEMICOLON_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_fieldname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldname" ):
                listener.enterFieldname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldname" ):
                listener.exitFieldname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldname" ):
                return visitor.visitFieldname(self)
            else:
                return visitor.visitChildren(self)




    def fieldname(self):

        localctx = backendgrammerParser.FieldnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_fieldname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.variablename()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_FILED_TYPE(self):
            return self.getToken(backendgrammerParser.STRING_FILED_TYPE, 0)

        def INT_FILED_TYPE(self):
            return self.getToken(backendgrammerParser.INT_FILED_TYPE, 0)

        def DATE_FILED_TYPE(self):
            return self.getToken(backendgrammerParser.DATE_FILED_TYPE, 0)

        def DOUBLE_FILED_TYPE(self):
            return self.getToken(backendgrammerParser.DOUBLE_FILED_TYPE, 0)

        def TIME_FILED_TYPE(self):
            return self.getToken(backendgrammerParser.TIME_FILED_TYPE, 0)

        def DATETIME_FILED_TYPE(self):
            return self.getToken(backendgrammerParser.DATETIME_FILED_TYPE, 0)

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_fieldtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldtype" ):
                listener.enterFieldtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldtype" ):
                listener.exitFieldtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldtype" ):
                return visitor.visitFieldtype(self)
            else:
                return visitor.visitChildren(self)




    def fieldtype(self):

        localctx = backendgrammerParser.FieldtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_fieldtype)
        try:
            self.state = 131
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 124
                self.match(backendgrammerParser.STRING_FILED_TYPE)
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 125
                self.match(backendgrammerParser.INT_FILED_TYPE)
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 126
                self.match(backendgrammerParser.DATE_FILED_TYPE)
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 4)
                self.state = 127
                self.match(backendgrammerParser.DOUBLE_FILED_TYPE)
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 5)
                self.state = 128
                self.match(backendgrammerParser.TIME_FILED_TYPE)
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 6)
                self.state = 129
                self.match(backendgrammerParser.DATETIME_FILED_TYPE)
                pass
            elif token in [68]:
                self.enterOuterAlt(localctx, 7)
                self.state = 130
                self.variablename()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldannotaionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pkoption(self):
            return self.getTypedRuleContext(backendgrammerParser.PkoptionContext,0)


        def nulloption(self):
            return self.getTypedRuleContext(backendgrammerParser.NulloptionContext,0)


        def uniqueoption(self):
            return self.getTypedRuleContext(backendgrammerParser.UniqueoptionContext,0)


        def validoption(self):
            return self.getTypedRuleContext(backendgrammerParser.ValidoptionContext,0)


        def fkoption(self):
            return self.getTypedRuleContext(backendgrammerParser.FkoptionContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_fieldannotaion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldannotaion" ):
                listener.enterFieldannotaion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldannotaion" ):
                listener.exitFieldannotaion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldannotaion" ):
                return visitor.visitFieldannotaion(self)
            else:
                return visitor.visitChildren(self)




    def fieldannotaion(self):

        localctx = backendgrammerParser.FieldannotaionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_fieldannotaion)
        try:
            self.state = 138
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 133
                self.pkoption()
                pass
            elif token in [46, 47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 134
                self.nulloption()
                pass
            elif token in [45]:
                self.enterOuterAlt(localctx, 3)
                self.state = 135
                self.uniqueoption()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 4)
                self.state = 136
                self.validoption()
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 5)
                self.state = 137
                self.fkoption()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FkoptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FK_KEY(self):
            return self.getToken(backendgrammerParser.FK_KEY, 0)

        def LEFT_PAR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_PAR_KEY, 0)

        def modelname(self):
            return self.getTypedRuleContext(backendgrammerParser.ModelnameContext,0)


        def DOT_KEY(self):
            return self.getToken(backendgrammerParser.DOT_KEY, 0)

        def fieldname(self):
            return self.getTypedRuleContext(backendgrammerParser.FieldnameContext,0)


        def RIGHT_PAR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_PAR_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_fkoption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFkoption" ):
                listener.enterFkoption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFkoption" ):
                listener.exitFkoption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFkoption" ):
                return visitor.visitFkoption(self)
            else:
                return visitor.visitChildren(self)




    def fkoption(self):

        localctx = backendgrammerParser.FkoptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_fkoption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(backendgrammerParser.FK_KEY)
            self.state = 141
            self.match(backendgrammerParser.LEFT_PAR_KEY)
            self.state = 142
            self.modelname()
            self.state = 143
            self.match(backendgrammerParser.DOT_KEY)
            self.state = 144
            self.fieldname()
            self.state = 145
            self.match(backendgrammerParser.RIGHT_PAR_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValidoptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALID_KEY(self):
            return self.getToken(backendgrammerParser.VALID_KEY, 0)

        def LEFT_BRACKET_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_BRACKET_KEY, 0)

        def RIGHT_BRACKET_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_BRACKET_KEY, 0)

        def validoptionparameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.ValidoptionparameterContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.ValidoptionparameterContext,i)


        def COMMA_KEY(self, i:int=None):
            if i is None:
                return self.getTokens(backendgrammerParser.COMMA_KEY)
            else:
                return self.getToken(backendgrammerParser.COMMA_KEY, i)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_validoption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValidoption" ):
                listener.enterValidoption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValidoption" ):
                listener.exitValidoption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValidoption" ):
                return visitor.visitValidoption(self)
            else:
                return visitor.visitChildren(self)




    def validoption(self):

        localctx = backendgrammerParser.ValidoptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_validoption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            self.match(backendgrammerParser.VALID_KEY)
            self.state = 148
            self.match(backendgrammerParser.LEFT_BRACKET_KEY)
            self.state = 157
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 149
                self.validoptionparameter()

            elif la_ == 2:
                self.state = 150
                self.validoptionparameter()
                self.state = 153 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 151
                    self.match(backendgrammerParser.COMMA_KEY)
                    self.state = 152
                    self.validoptionparameter()
                    self.state = 155 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==25):
                        break



            self.state = 159
            self.match(backendgrammerParser.RIGHT_BRACKET_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValidoptionparameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def max_validoptionparameter(self):
            return self.getTypedRuleContext(backendgrammerParser.Max_validoptionparameterContext,0)


        def min_validoptionparameter(self):
            return self.getTypedRuleContext(backendgrammerParser.Min_validoptionparameterContext,0)


        def wildpattern_validoptionparameter(self):
            return self.getTypedRuleContext(backendgrammerParser.Wildpattern_validoptionparameterContext,0)


        def include_validoptionparameter(self):
            return self.getTypedRuleContext(backendgrammerParser.Include_validoptionparameterContext,0)


        def exclude_validoptionparameter(self):
            return self.getTypedRuleContext(backendgrammerParser.Exclude_validoptionparameterContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_validoptionparameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValidoptionparameter" ):
                listener.enterValidoptionparameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValidoptionparameter" ):
                listener.exitValidoptionparameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValidoptionparameter" ):
                return visitor.visitValidoptionparameter(self)
            else:
                return visitor.visitChildren(self)




    def validoptionparameter(self):

        localctx = backendgrammerParser.ValidoptionparameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_validoptionparameter)
        try:
            self.state = 166
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 161
                self.max_validoptionparameter()
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 2)
                self.state = 162
                self.min_validoptionparameter()
                pass
            elif token in [42]:
                self.enterOuterAlt(localctx, 3)
                self.state = 163
                self.wildpattern_validoptionparameter()
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 4)
                self.state = 164
                self.include_validoptionparameter()
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 5)
                self.state = 165
                self.exclude_validoptionparameter()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exclude_validoptionparameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLUDE_KEY(self):
            return self.getToken(backendgrammerParser.EXCLUDE_KEY, 0)

        def EQUALSIGN_KEY(self):
            return self.getToken(backendgrammerParser.EQUALSIGN_KEY, 0)

        def LEFT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_CURLBR_KEY, 0)

        def RIGHT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_CURLBR_KEY, 0)

        def genericvalue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.GenericvalueContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.GenericvalueContext,i)


        def COMMA_KEY(self, i:int=None):
            if i is None:
                return self.getTokens(backendgrammerParser.COMMA_KEY)
            else:
                return self.getToken(backendgrammerParser.COMMA_KEY, i)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_exclude_validoptionparameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExclude_validoptionparameter" ):
                listener.enterExclude_validoptionparameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExclude_validoptionparameter" ):
                listener.exitExclude_validoptionparameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExclude_validoptionparameter" ):
                return visitor.visitExclude_validoptionparameter(self)
            else:
                return visitor.visitChildren(self)




    def exclude_validoptionparameter(self):

        localctx = backendgrammerParser.Exclude_validoptionparameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_exclude_validoptionparameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(backendgrammerParser.EXCLUDE_KEY)
            self.state = 169
            self.match(backendgrammerParser.EQUALSIGN_KEY)
            self.state = 170
            self.match(backendgrammerParser.LEFT_CURLBR_KEY)
            self.state = 179
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.state = 171
                self.genericvalue()

            elif la_ == 2:
                self.state = 172
                self.genericvalue()
                self.state = 175 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 173
                    self.match(backendgrammerParser.COMMA_KEY)
                    self.state = 174
                    self.genericvalue()
                    self.state = 177 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==25):
                        break



            self.state = 181
            self.match(backendgrammerParser.RIGHT_CURLBR_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Include_validoptionparameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE_KEY(self):
            return self.getToken(backendgrammerParser.INCLUDE_KEY, 0)

        def EQUALSIGN_KEY(self):
            return self.getToken(backendgrammerParser.EQUALSIGN_KEY, 0)

        def LEFT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_CURLBR_KEY, 0)

        def RIGHT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_CURLBR_KEY, 0)

        def genericvalue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.GenericvalueContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.GenericvalueContext,i)


        def COMMA_KEY(self, i:int=None):
            if i is None:
                return self.getTokens(backendgrammerParser.COMMA_KEY)
            else:
                return self.getToken(backendgrammerParser.COMMA_KEY, i)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_include_validoptionparameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude_validoptionparameter" ):
                listener.enterInclude_validoptionparameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude_validoptionparameter" ):
                listener.exitInclude_validoptionparameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInclude_validoptionparameter" ):
                return visitor.visitInclude_validoptionparameter(self)
            else:
                return visitor.visitChildren(self)




    def include_validoptionparameter(self):

        localctx = backendgrammerParser.Include_validoptionparameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_include_validoptionparameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(backendgrammerParser.INCLUDE_KEY)
            self.state = 184
            self.match(backendgrammerParser.EQUALSIGN_KEY)
            self.state = 185
            self.match(backendgrammerParser.LEFT_CURLBR_KEY)
            self.state = 194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 186
                self.genericvalue()

            elif la_ == 2:
                self.state = 187
                self.genericvalue()
                self.state = 190 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 188
                    self.match(backendgrammerParser.COMMA_KEY)
                    self.state = 189
                    self.genericvalue()
                    self.state = 192 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==25):
                        break



            self.state = 196
            self.match(backendgrammerParser.RIGHT_CURLBR_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Wildpattern_validoptionparameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WILD_PATTERN_KEY(self):
            return self.getToken(backendgrammerParser.WILD_PATTERN_KEY, 0)

        def EQUALSIGN_KEY(self):
            return self.getToken(backendgrammerParser.EQUALSIGN_KEY, 0)

        def stringvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.StringvalueContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_wildpattern_validoptionparameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWildpattern_validoptionparameter" ):
                listener.enterWildpattern_validoptionparameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWildpattern_validoptionparameter" ):
                listener.exitWildpattern_validoptionparameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWildpattern_validoptionparameter" ):
                return visitor.visitWildpattern_validoptionparameter(self)
            else:
                return visitor.visitChildren(self)




    def wildpattern_validoptionparameter(self):

        localctx = backendgrammerParser.Wildpattern_validoptionparameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_wildpattern_validoptionparameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(backendgrammerParser.WILD_PATTERN_KEY)
            self.state = 199
            self.match(backendgrammerParser.EQUALSIGN_KEY)
            self.state = 200
            self.stringvalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Min_validoptionparameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MIN_KEY(self):
            return self.getToken(backendgrammerParser.MIN_KEY, 0)

        def EQUALSIGN_KEY(self):
            return self.getToken(backendgrammerParser.EQUALSIGN_KEY, 0)

        def genericvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.GenericvalueContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_min_validoptionparameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMin_validoptionparameter" ):
                listener.enterMin_validoptionparameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMin_validoptionparameter" ):
                listener.exitMin_validoptionparameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMin_validoptionparameter" ):
                return visitor.visitMin_validoptionparameter(self)
            else:
                return visitor.visitChildren(self)




    def min_validoptionparameter(self):

        localctx = backendgrammerParser.Min_validoptionparameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_min_validoptionparameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(backendgrammerParser.MIN_KEY)
            self.state = 203
            self.match(backendgrammerParser.EQUALSIGN_KEY)
            self.state = 204
            self.genericvalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Max_validoptionparameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAX_KEY(self):
            return self.getToken(backendgrammerParser.MAX_KEY, 0)

        def EQUALSIGN_KEY(self):
            return self.getToken(backendgrammerParser.EQUALSIGN_KEY, 0)

        def genericvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.GenericvalueContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_max_validoptionparameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMax_validoptionparameter" ):
                listener.enterMax_validoptionparameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMax_validoptionparameter" ):
                listener.exitMax_validoptionparameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMax_validoptionparameter" ):
                return visitor.visitMax_validoptionparameter(self)
            else:
                return visitor.visitChildren(self)




    def max_validoptionparameter(self):

        localctx = backendgrammerParser.Max_validoptionparameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_max_validoptionparameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(backendgrammerParser.MAX_KEY)
            self.state = 207
            self.match(backendgrammerParser.EQUALSIGN_KEY)
            self.state = 208
            self.genericvalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniqueoptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIQUE_KEY(self):
            return self.getToken(backendgrammerParser.UNIQUE_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_uniqueoption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniqueoption" ):
                listener.enterUniqueoption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniqueoption" ):
                listener.exitUniqueoption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniqueoption" ):
                return visitor.visitUniqueoption(self)
            else:
                return visitor.visitChildren(self)




    def uniqueoption(self):

        localctx = backendgrammerParser.UniqueoptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_uniqueoption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(backendgrammerParser.UNIQUE_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NulloptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULLABLE_KEY(self):
            return self.getToken(backendgrammerParser.NULLABLE_KEY, 0)

        def NON_NULLABLE_KEY(self):
            return self.getToken(backendgrammerParser.NON_NULLABLE_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_nulloption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNulloption" ):
                listener.enterNulloption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNulloption" ):
                listener.exitNulloption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNulloption" ):
                return visitor.visitNulloption(self)
            else:
                return visitor.visitChildren(self)




    def nulloption(self):

        localctx = backendgrammerParser.NulloptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_nulloption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            _la = self._input.LA(1)
            if not(_la==46 or _la==47):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PkoptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PK_KEY(self):
            return self.getToken(backendgrammerParser.PK_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_pkoption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPkoption" ):
                listener.enterPkoption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPkoption" ):
                listener.exitPkoption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPkoption" ):
                return visitor.visitPkoption(self)
            else:
                return visitor.visitChildren(self)




    def pkoption(self):

        localctx = backendgrammerParser.PkoptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_pkoption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(backendgrammerParser.PK_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumroleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM_KEY(self):
            return self.getToken(backendgrammerParser.ENUM_KEY, 0)

        def enumname(self):
            return self.getTypedRuleContext(backendgrammerParser.EnumnameContext,0)


        def LEFT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_CURLBR_KEY, 0)

        def enumblock(self):
            return self.getTypedRuleContext(backendgrammerParser.EnumblockContext,0)


        def RIGHT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_CURLBR_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_enumrole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumrole" ):
                listener.enterEnumrole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumrole" ):
                listener.exitEnumrole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumrole" ):
                return visitor.visitEnumrole(self)
            else:
                return visitor.visitChildren(self)




    def enumrole(self):

        localctx = backendgrammerParser.EnumroleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_enumrole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(backendgrammerParser.ENUM_KEY)
            self.state = 217
            self.enumname()
            self.state = 218
            self.match(backendgrammerParser.LEFT_CURLBR_KEY)
            self.state = 219
            self.enumblock()
            self.state = 220
            self.match(backendgrammerParser.RIGHT_CURLBR_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_enumname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumname" ):
                listener.enterEnumname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumname" ):
                listener.exitEnumname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumname" ):
                return visitor.visitEnumname(self)
            else:
                return visitor.visitChildren(self)




    def enumname(self):

        localctx = backendgrammerParser.EnumnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_enumname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.variablename()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumitem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.EnumitemContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.EnumitemContext,i)


        def COMMA_KEY(self, i:int=None):
            if i is None:
                return self.getTokens(backendgrammerParser.COMMA_KEY)
            else:
                return self.getToken(backendgrammerParser.COMMA_KEY, i)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_enumblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumblock" ):
                listener.enterEnumblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumblock" ):
                listener.exitEnumblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumblock" ):
                return visitor.visitEnumblock(self)
            else:
                return visitor.visitChildren(self)




    def enumblock(self):

        localctx = backendgrammerParser.EnumblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_enumblock)
        self._la = 0 # Token type
        try:
            self.state = 233
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 224
                self.enumitem()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 225
                self.enumitem()
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==25:
                    self.state = 226
                    self.match(backendgrammerParser.COMMA_KEY)
                    self.state = 227
                    self.enumitem()
                    self.state = 232
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumitemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.GenericvalueContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_enumitem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumitem" ):
                listener.enterEnumitem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumitem" ):
                listener.exitEnumitem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumitem" ):
                return visitor.visitEnumitem(self)
            else:
                return visitor.visitChildren(self)




    def enumitem(self):

        localctx = backendgrammerParser.EnumitemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_enumitem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.genericvalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndpointruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operationId(self):
            return self.getTypedRuleContext(backendgrammerParser.OperationIdContext,0)


        def COLON_KEY(self):
            return self.getToken(backendgrammerParser.COLON_KEY, 0)

        def htttpMethod(self):
            return self.getTypedRuleContext(backendgrammerParser.HtttpMethodContext,0)


        def endpointurl(self):
            return self.getTypedRuleContext(backendgrammerParser.EndpointurlContext,0)


        def LEFT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_CURLBR_KEY, 0)

        def endpoinblock(self):
            return self.getTypedRuleContext(backendgrammerParser.EndpoinblockContext,0)


        def RIGHT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_CURLBR_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_endpointrule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndpointrule" ):
                listener.enterEndpointrule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndpointrule" ):
                listener.exitEndpointrule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndpointrule" ):
                return visitor.visitEndpointrule(self)
            else:
                return visitor.visitChildren(self)




    def endpointrule(self):

        localctx = backendgrammerParser.EndpointruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_endpointrule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(backendgrammerParser.T__0)
            self.state = 238
            self.operationId()
            self.state = 239
            self.match(backendgrammerParser.COLON_KEY)
            self.state = 240
            self.htttpMethod()
            self.state = 241
            self.endpointurl()
            self.state = 242
            self.match(backendgrammerParser.LEFT_CURLBR_KEY)
            self.state = 243
            self.endpoinblock()
            self.state = 244
            self.match(backendgrammerParser.RIGHT_CURLBR_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationIdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_operationId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperationId" ):
                listener.enterOperationId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperationId" ):
                listener.exitOperationId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperationId" ):
                return visitor.visitOperationId(self)
            else:
                return visitor.visitChildren(self)




    def operationId(self):

        localctx = backendgrammerParser.OperationIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_operationId)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            self.variablename()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HtttpMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET_KEY(self):
            return self.getToken(backendgrammerParser.GET_KEY, 0)

        def POST_KEY(self):
            return self.getToken(backendgrammerParser.POST_KEY, 0)

        def PUT_KEY(self):
            return self.getToken(backendgrammerParser.PUT_KEY, 0)

        def DELETE_KEY(self):
            return self.getToken(backendgrammerParser.DELETE_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_htttpMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHtttpMethod" ):
                listener.enterHtttpMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHtttpMethod" ):
                listener.exitHtttpMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHtttpMethod" ):
                return visitor.visitHtttpMethod(self)
            else:
                return visitor.visitChildren(self)




    def htttpMethod(self):

        localctx = backendgrammerParser.HtttpMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_htttpMethod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 16888498602639360) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndpointurlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.StringvalueContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_endpointurl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndpointurl" ):
                listener.enterEndpointurl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndpointurl" ):
                listener.exitEndpointurl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndpointurl" ):
                return visitor.visitEndpointurl(self)
            else:
                return visitor.visitChildren(self)




    def endpointurl(self):

        localctx = backendgrammerParser.EndpointurlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_endpointurl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.stringvalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndpoinblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def responseblock(self):
            return self.getTypedRuleContext(backendgrammerParser.ResponseblockContext,0)


        def SEMICOLON_KEY(self, i:int=None):
            if i is None:
                return self.getTokens(backendgrammerParser.SEMICOLON_KEY)
            else:
                return self.getToken(backendgrammerParser.SEMICOLON_KEY, i)

        def inputblock(self):
            return self.getTypedRuleContext(backendgrammerParser.InputblockContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_endpoinblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndpoinblock" ):
                listener.enterEndpoinblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndpoinblock" ):
                listener.exitEndpoinblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndpoinblock" ):
                return visitor.visitEndpoinblock(self)
            else:
                return visitor.visitChildren(self)




    def endpoinblock(self):

        localctx = backendgrammerParser.EndpoinblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_endpoinblock)
        try:
            self.state = 265
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 252
                self.responseblock()
                self.state = 253
                self.match(backendgrammerParser.SEMICOLON_KEY)
                self.state = 254
                self.inputblock()
                self.state = 255
                self.match(backendgrammerParser.SEMICOLON_KEY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 257
                self.inputblock()
                self.state = 258
                self.match(backendgrammerParser.SEMICOLON_KEY)
                self.state = 259
                self.responseblock()
                self.state = 260
                self.match(backendgrammerParser.SEMICOLON_KEY)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 262
                self.responseblock()
                self.state = 263
                self.match(backendgrammerParser.SEMICOLON_KEY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponseblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESPONSE_KEY(self):
            return self.getToken(backendgrammerParser.RESPONSE_KEY, 0)

        def COLON_KEY(self):
            return self.getToken(backendgrammerParser.COLON_KEY, 0)

        def responseblock_inner(self):
            return self.getTypedRuleContext(backendgrammerParser.Responseblock_innerContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_responseblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponseblock" ):
                listener.enterResponseblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponseblock" ):
                listener.exitResponseblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponseblock" ):
                return visitor.visitResponseblock(self)
            else:
                return visitor.visitChildren(self)




    def responseblock(self):

        localctx = backendgrammerParser.ResponseblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_responseblock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 267
            self.match(backendgrammerParser.RESPONSE_KEY)
            self.state = 268
            self.match(backendgrammerParser.COLON_KEY)
            self.state = 269
            self.responseblock_inner()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Responseblock_innerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modelname(self):
            return self.getTypedRuleContext(backendgrammerParser.ModelnameContext,0)


        def RELATIONAL_KEY(self):
            return self.getToken(backendgrammerParser.RELATIONAL_KEY, 0)

        def LEFT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_CURLBR_KEY, 0)

        def relationalcode(self):
            return self.getTypedRuleContext(backendgrammerParser.RelationalcodeContext,0)


        def RIGHT_CURLBR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_CURLBR_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_responseblock_inner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponseblock_inner" ):
                listener.enterResponseblock_inner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponseblock_inner" ):
                listener.exitResponseblock_inner(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponseblock_inner" ):
                return visitor.visitResponseblock_inner(self)
            else:
                return visitor.visitChildren(self)




    def responseblock_inner(self):

        localctx = backendgrammerParser.Responseblock_innerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_responseblock_inner)
        try:
            self.state = 277
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [68]:
                self.enterOuterAlt(localctx, 1)
                self.state = 271
                self.modelname()
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 2)
                self.state = 272
                self.match(backendgrammerParser.RELATIONAL_KEY)
                self.state = 273
                self.match(backendgrammerParser.LEFT_CURLBR_KEY)
                self.state = 274
                self.relationalcode()
                self.state = 275
                self.match(backendgrammerParser.RIGHT_CURLBR_KEY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationalcodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN_ARROW_KEY(self):
            return self.getToken(backendgrammerParser.RETURN_ARROW_KEY, 0)

        def expr_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Expr_relationalContext,0)


        def SEMICOLON_KEY(self):
            return self.getToken(backendgrammerParser.SEMICOLON_KEY, 0)

        def define_variable_relational(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.Define_variable_relationalContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.Define_variable_relationalContext,i)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_relationalcode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalcode" ):
                listener.enterRelationalcode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalcode" ):
                listener.exitRelationalcode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationalcode" ):
                return visitor.visitRelationalcode(self)
            else:
                return visitor.visitChildren(self)




    def relationalcode(self):

        localctx = backendgrammerParser.RelationalcodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_relationalcode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==68:
                self.state = 279
                self.define_variable_relational()
                self.state = 284
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 285
            self.match(backendgrammerParser.RETURN_ARROW_KEY)
            self.state = 286
            self.expr_relational()
            self.state = 287
            self.match(backendgrammerParser.SEMICOLON_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Define_variable_relationalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def EQUALSIGN_KEY(self):
            return self.getToken(backendgrammerParser.EQUALSIGN_KEY, 0)

        def expr_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Expr_relationalContext,0)


        def SEMICOLON_KEY(self):
            return self.getToken(backendgrammerParser.SEMICOLON_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_define_variable_relational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine_variable_relational" ):
                listener.enterDefine_variable_relational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine_variable_relational" ):
                listener.exitDefine_variable_relational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefine_variable_relational" ):
                return visitor.visitDefine_variable_relational(self)
            else:
                return visitor.visitChildren(self)




    def define_variable_relational(self):

        localctx = backendgrammerParser.Define_variable_relationalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_define_variable_relational)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            self.variablename()
            self.state = 290
            self.match(backendgrammerParser.EQUALSIGN_KEY)
            self.state = 291
            self.expr_relational()
            self.state = 292
            self.match(backendgrammerParser.SEMICOLON_KEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expr_relationalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Term_relationalContext,0)


        def built_in_functions_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Built_in_functions_relationalContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_expr_relational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_relational" ):
                listener.enterExpr_relational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_relational" ):
                listener.exitExpr_relational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_relational" ):
                return visitor.visitExpr_relational(self)
            else:
                return visitor.visitChildren(self)




    def expr_relational(self):

        localctx = backendgrammerParser.Expr_relationalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_expr_relational)
        try:
            self.state = 296
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2, 3, 19, 65, 66, 67, 68]:
                self.enterOuterAlt(localctx, 1)
                self.state = 294
                self.term_relational(0)
                pass
            elif token in [58, 59, 60, 61, 62, 63, 64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.built_in_functions_relational()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term_relationalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def idom_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Idom_relationalContext,0)


        def term_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Term_relationalContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_term_relational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm_relational" ):
                listener.enterTerm_relational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm_relational" ):
                listener.exitTerm_relational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm_relational" ):
                return visitor.visitTerm_relational(self)
            else:
                return visitor.visitChildren(self)



    def term_relational(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = backendgrammerParser.Term_relationalContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 64
        self.enterRecursionRule(localctx, 64, self.RULE_term_relational, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.idom_relational(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 306
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = backendgrammerParser.Term_relationalContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_term_relational)
                    self.state = 301
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 302
                    _la = self._input.LA(1)
                    if not(_la==2 or _la==3):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 303
                    self.idom_relational(0) 
                self.state = 308
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Idom_relationalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Factor_relationalContext,0)


        def idom_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Idom_relationalContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_idom_relational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdom_relational" ):
                listener.enterIdom_relational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdom_relational" ):
                listener.exitIdom_relational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdom_relational" ):
                return visitor.visitIdom_relational(self)
            else:
                return visitor.visitChildren(self)



    def idom_relational(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = backendgrammerParser.Idom_relationalContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 66
        self.enterRecursionRule(localctx, 66, self.RULE_idom_relational, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.factor_relational()
            self._ctx.stop = self._input.LT(-1)
            self.state = 317
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = backendgrammerParser.Idom_relationalContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_idom_relational)
                    self.state = 312
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 313
                    _la = self._input.LA(1)
                    if not(_la==4 or _la==5):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 314
                    self.factor_relational() 
                self.state = 319
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Factor_relationalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def genericvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.GenericvalueContext,0)


        def LEFT_PAR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_PAR_KEY, 0)

        def term_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Term_relationalContext,0)


        def RIGHT_PAR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_PAR_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_factor_relational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor_relational" ):
                listener.enterFactor_relational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor_relational" ):
                listener.exitFactor_relational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor_relational" ):
                return visitor.visitFactor_relational(self)
            else:
                return visitor.visitChildren(self)




    def factor_relational(self):

        localctx = backendgrammerParser.Factor_relationalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_factor_relational)
        try:
            self.state = 326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [68]:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.variablename()
                pass
            elif token in [2, 3, 65, 66, 67]:
                self.enterOuterAlt(localctx, 2)
                self.state = 321
                self.genericvalue()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 3)
                self.state = 322
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 323
                self.term_relational(0)
                self.state = 324
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INPUT_KEY(self):
            return self.getToken(backendgrammerParser.INPUT_KEY, 0)

        def COLON_KEY(self):
            return self.getToken(backendgrammerParser.COLON_KEY, 0)

        def jsonstring(self):
            return self.getTypedRuleContext(backendgrammerParser.JsonstringContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_inputblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInputblock" ):
                listener.enterInputblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInputblock" ):
                listener.exitInputblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputblock" ):
                return visitor.visitInputblock(self)
            else:
                return visitor.visitChildren(self)




    def inputblock(self):

        localctx = backendgrammerParser.InputblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_inputblock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.match(backendgrammerParser.INPUT_KEY)
            self.state = 329
            self.match(backendgrammerParser.COLON_KEY)
            self.state = 330
            self.jsonstring()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JsonstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.StringvalueContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_jsonstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJsonstring" ):
                listener.enterJsonstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJsonstring" ):
                listener.exitJsonstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJsonstring" ):
                return visitor.visitJsonstring(self)
            else:
                return visitor.visitChildren(self)




    def jsonstring(self):

        localctx = backendgrammerParser.JsonstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_jsonstring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            self.stringvalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Built_in_functions_relationalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT_FUNCTION_KEY(self):
            return self.getToken(backendgrammerParser.SELECT_FUNCTION_KEY, 0)

        def LEFT_ANGLE_BRACKET_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_ANGLE_BRACKET_KEY, 0)

        def RIGHT_ANGLE_BRACKET_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_ANGLE_BRACKET_KEY, 0)

        def LEFT_PAR_KEY(self):
            return self.getToken(backendgrammerParser.LEFT_PAR_KEY, 0)

        def expr_relational(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.Expr_relationalContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.Expr_relationalContext,i)


        def RIGHT_PAR_KEY(self):
            return self.getToken(backendgrammerParser.RIGHT_PAR_KEY, 0)

        def key_value_pair_select_relational(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.Key_value_pair_select_relationalContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.Key_value_pair_select_relationalContext,i)


        def COMMA_KEY(self, i:int=None):
            if i is None:
                return self.getTokens(backendgrammerParser.COMMA_KEY)
            else:
                return self.getToken(backendgrammerParser.COMMA_KEY, i)

        def PROJECT_FUNCTION_KEY(self):
            return self.getToken(backendgrammerParser.PROJECT_FUNCTION_KEY, 0)

        def variablename(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.VariablenameContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,i)


        def JOIN_FUNCTION_KEY(self):
            return self.getToken(backendgrammerParser.JOIN_FUNCTION_KEY, 0)

        def LEN_FUNCTION_KEY(self):
            return self.getToken(backendgrammerParser.LEN_FUNCTION_KEY, 0)

        def SET_FUNCTION_KEY(self):
            return self.getToken(backendgrammerParser.SET_FUNCTION_KEY, 0)

        def ORDERBY_FUNCTION_KEY(self):
            return self.getToken(backendgrammerParser.ORDERBY_FUNCTION_KEY, 0)

        def booleanvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.BooleanvalueContext,0)


        def LIMIT_FUNCTION_KEY(self):
            return self.getToken(backendgrammerParser.LIMIT_FUNCTION_KEY, 0)

        def term_relational(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(backendgrammerParser.Term_relationalContext)
            else:
                return self.getTypedRuleContext(backendgrammerParser.Term_relationalContext,i)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_built_in_functions_relational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuilt_in_functions_relational" ):
                listener.enterBuilt_in_functions_relational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuilt_in_functions_relational" ):
                listener.exitBuilt_in_functions_relational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuilt_in_functions_relational" ):
                return visitor.visitBuilt_in_functions_relational(self)
            else:
                return visitor.visitChildren(self)




    def built_in_functions_relational(self):

        localctx = backendgrammerParser.Built_in_functions_relationalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_built_in_functions_relational)
        self._la = 0 # Token type
        try:
            self.state = 420
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [58]:
                self.enterOuterAlt(localctx, 1)
                self.state = 334
                self.match(backendgrammerParser.SELECT_FUNCTION_KEY)
                self.state = 335
                self.match(backendgrammerParser.LEFT_ANGLE_BRACKET_KEY)
                self.state = 344
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==68:
                    self.state = 336
                    self.key_value_pair_select_relational()
                    self.state = 341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==25:
                        self.state = 337
                        self.match(backendgrammerParser.COMMA_KEY)
                        self.state = 338
                        self.key_value_pair_select_relational()
                        self.state = 343
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 346
                self.match(backendgrammerParser.RIGHT_ANGLE_BRACKET_KEY)
                self.state = 347
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 348
                self.expr_relational()
                self.state = 349
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            elif token in [59]:
                self.enterOuterAlt(localctx, 2)
                self.state = 351
                self.match(backendgrammerParser.PROJECT_FUNCTION_KEY)
                self.state = 352
                self.match(backendgrammerParser.LEFT_ANGLE_BRACKET_KEY)

                self.state = 353
                self.variablename()
                self.state = 358
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==25:
                    self.state = 354
                    self.match(backendgrammerParser.COMMA_KEY)
                    self.state = 355
                    self.variablename()
                    self.state = 360
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 361
                self.match(backendgrammerParser.RIGHT_ANGLE_BRACKET_KEY)
                self.state = 362
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 363
                self.expr_relational()
                self.state = 364
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            elif token in [60]:
                self.enterOuterAlt(localctx, 3)
                self.state = 366
                self.match(backendgrammerParser.JOIN_FUNCTION_KEY)
                self.state = 367
                self.match(backendgrammerParser.LEFT_ANGLE_BRACKET_KEY)

                self.state = 368
                self.variablename()
                self.state = 373
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==25:
                    self.state = 369
                    self.match(backendgrammerParser.COMMA_KEY)
                    self.state = 370
                    self.variablename()
                    self.state = 375
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 376
                self.match(backendgrammerParser.RIGHT_ANGLE_BRACKET_KEY)
                self.state = 377
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 378
                self.expr_relational()
                self.state = 379
                self.match(backendgrammerParser.COMMA_KEY)
                self.state = 380
                self.expr_relational()
                self.state = 381
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 4)
                self.state = 383
                self.match(backendgrammerParser.LEN_FUNCTION_KEY)
                self.state = 384
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 385
                self.expr_relational()
                self.state = 386
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 5)
                self.state = 388
                self.match(backendgrammerParser.SET_FUNCTION_KEY)
                self.state = 389
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 390
                self.expr_relational()
                self.state = 391
                self.match(backendgrammerParser.COMMA_KEY)
                self.state = 392
                self.expr_relational()
                self.state = 393
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            elif token in [63]:
                self.enterOuterAlt(localctx, 6)
                self.state = 395
                self.match(backendgrammerParser.ORDERBY_FUNCTION_KEY)
                self.state = 396
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 397
                self.expr_relational()
                self.state = 398
                self.match(backendgrammerParser.COMMA_KEY)
                self.state = 399
                self.booleanvalue()
                self.state = 400
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 7)
                self.state = 402
                self.match(backendgrammerParser.LIMIT_FUNCTION_KEY)
                self.state = 403
                self.match(backendgrammerParser.LEFT_ANGLE_BRACKET_KEY)
                self.state = 405
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 524300) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 15) != 0):
                    self.state = 404
                    self.term_relational(0)


                self.state = 407
                self.match(backendgrammerParser.COMMA_KEY)
                self.state = 409
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 524300) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 15) != 0):
                    self.state = 408
                    self.term_relational(0)


                self.state = 411
                self.match(backendgrammerParser.COMMA_KEY)
                self.state = 413
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 524300) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 15) != 0):
                    self.state = 412
                    self.term_relational(0)


                self.state = 415
                self.match(backendgrammerParser.RIGHT_ANGLE_BRACKET_KEY)
                self.state = 416
                self.match(backendgrammerParser.LEFT_PAR_KEY)
                self.state = 417
                self.expr_relational()
                self.state = 418
                self.match(backendgrammerParser.RIGHT_PAR_KEY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Key_value_pair_select_relationalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variablename(self):
            return self.getTypedRuleContext(backendgrammerParser.VariablenameContext,0)


        def binary_logical_operation(self):
            return self.getTypedRuleContext(backendgrammerParser.Binary_logical_operationContext,0)


        def term_relational(self):
            return self.getTypedRuleContext(backendgrammerParser.Term_relationalContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_key_value_pair_select_relational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKey_value_pair_select_relational" ):
                listener.enterKey_value_pair_select_relational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKey_value_pair_select_relational" ):
                listener.exitKey_value_pair_select_relational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKey_value_pair_select_relational" ):
                return visitor.visitKey_value_pair_select_relational(self)
            else:
                return visitor.visitChildren(self)




    def key_value_pair_select_relational(self):

        localctx = backendgrammerParser.Key_value_pair_select_relationalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_key_value_pair_select_relational)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.variablename()
            self.state = 423
            self.binary_logical_operation()
            self.state = 424
            self.term_relational(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Binary_logical_operationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL_KEY(self):
            return self.getToken(backendgrammerParser.EQUAL_KEY, 0)

        def LESSTHAN_KEY(self):
            return self.getToken(backendgrammerParser.LESSTHAN_KEY, 0)

        def GREATERTHAN_KEY(self):
            return self.getToken(backendgrammerParser.GREATERTHAN_KEY, 0)

        def GREATERTHAN_OR_EQUAL_KEY(self):
            return self.getToken(backendgrammerParser.GREATERTHAN_OR_EQUAL_KEY, 0)

        def LESSTHAN_OR_EQUAL_KEY(self):
            return self.getToken(backendgrammerParser.LESSTHAN_OR_EQUAL_KEY, 0)

        def NOT_EQUAL_KEY(self):
            return self.getToken(backendgrammerParser.NOT_EQUAL_KEY, 0)

        def NOT_LESSTHAN_KEY(self):
            return self.getToken(backendgrammerParser.NOT_LESSTHAN_KEY, 0)

        def NOT_GREATERTHAN_KEY(self):
            return self.getToken(backendgrammerParser.NOT_GREATERTHAN_KEY, 0)

        def NOT_GREATERTHAN_OR_EQUAL_KEY(self):
            return self.getToken(backendgrammerParser.NOT_GREATERTHAN_OR_EQUAL_KEY, 0)

        def NOT_LESSTHAN_OR_EQUAL_KEY(self):
            return self.getToken(backendgrammerParser.NOT_LESSTHAN_OR_EQUAL_KEY, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_binary_logical_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinary_logical_operation" ):
                listener.enterBinary_logical_operation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinary_logical_operation" ):
                listener.exitBinary_logical_operation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinary_logical_operation" ):
                return visitor.visitBinary_logical_operation(self)
            else:
                return visitor.visitChildren(self)




    def binary_logical_operation(self):

        localctx = backendgrammerParser.Binary_logical_operationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_binary_logical_operation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1098437885952) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericvalueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.IntvalueContext,0)


        def stringvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.StringvalueContext,0)


        def booleanvalue(self):
            return self.getTypedRuleContext(backendgrammerParser.BooleanvalueContext,0)


        def getRuleIndex(self):
            return backendgrammerParser.RULE_genericvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericvalue" ):
                listener.enterGenericvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericvalue" ):
                listener.exitGenericvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericvalue" ):
                return visitor.visitGenericvalue(self)
            else:
                return visitor.visitChildren(self)




    def genericvalue(self):

        localctx = backendgrammerParser.GenericvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_genericvalue)
        try:
            self.state = 431
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2, 3, 65]:
                self.enterOuterAlt(localctx, 1)
                self.state = 428
                self.intvalue()
                pass
            elif token in [66]:
                self.enterOuterAlt(localctx, 2)
                self.state = 429
                self.stringvalue()
                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 3)
                self.state = 430
                self.booleanvalue()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntvalueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGITS(self):
            return self.getToken(backendgrammerParser.DIGITS, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_intvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntvalue" ):
                listener.enterIntvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntvalue" ):
                listener.exitIntvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntvalue" ):
                return visitor.visitIntvalue(self)
            else:
                return visitor.visitChildren(self)




    def intvalue(self):

        localctx = backendgrammerParser.IntvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_intvalue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==2 or _la==3:
                self.state = 433
                _la = self._input.LA(1)
                if not(_la==2 or _la==3):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 436
            self.match(backendgrammerParser.DIGITS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringvalueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRINGVALUE(self):
            return self.getToken(backendgrammerParser.STRINGVALUE, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_stringvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringvalue" ):
                listener.enterStringvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringvalue" ):
                listener.exitStringvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringvalue" ):
                return visitor.visitStringvalue(self)
            else:
                return visitor.visitChildren(self)




    def stringvalue(self):

        localctx = backendgrammerParser.StringvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_stringvalue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 438
            self.match(backendgrammerParser.STRINGVALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanvalueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEANVALUE(self):
            return self.getToken(backendgrammerParser.BOOLEANVALUE, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_booleanvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanvalue" ):
                listener.enterBooleanvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanvalue" ):
                listener.exitBooleanvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanvalue" ):
                return visitor.visitBooleanvalue(self)
            else:
                return visitor.visitChildren(self)




    def booleanvalue(self):

        localctx = backendgrammerParser.BooleanvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_booleanvalue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 440
            self.match(backendgrammerParser.BOOLEANVALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariablenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLEID(self):
            return self.getToken(backendgrammerParser.VARIABLEID, 0)

        def getRuleIndex(self):
            return backendgrammerParser.RULE_variablename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariablename" ):
                listener.enterVariablename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariablename" ):
                listener.exitVariablename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariablename" ):
                return visitor.visitVariablename(self)
            else:
                return visitor.visitChildren(self)




    def variablename(self):

        localctx = backendgrammerParser.VariablenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_variablename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            self.match(backendgrammerParser.VARIABLEID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[32] = self.term_relational_sempred
        self._predicates[33] = self.idom_relational_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def term_relational_sempred(self, localctx:Term_relationalContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def idom_relational_sempred(self, localctx:Idom_relationalContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         




